#!/usr/bin/perl

#
# Copyright 2002, 2009 Seanodes Ltd http://www.seanodes.com. All rights
# reserved and protected by French, UK, U.S. and other countries' copyright laws.
# This file is part of Exanodes project and is subject to the terms
# and conditions defined in the LICENSE file which is present in the root
# directory of the project.
#

#
# This is a utility file that tranform a regular .h include file containing mostly
# #define statements to a perl equivalent.
# This tool is specific to driveFUSION's .h error file
#
#
use strict;
use warnings;
use Data::Dumper;
#use encoding 'latin1';

sub usage
{
  my $HIGH = `tput bold`;
  my $NORM = `tput sgr0`;

  printf(".$HIGH Usage$NORM : c-error-2-perl <error file .h> <error file .c> <perl file1> [<perl file2>]\n");
  printf("\tTransform the <error file .h> and <error file .c> to 2 perl packages <perl file1>\n");
  printf("\t and if defined, a specific file with only the variables and strings: <perl file2>\n");

  printf("\n.$HIGH Examples$NORM :\n");
  printf("$HIGH\tc-error-2-perl common/include/exa_error.h common/lib/exa_error.c test/lib/exa_error.pm$NORM\n");

}

if ((scalar(@ARGV) != 3) and (scalar(@ARGV) != 4) and (scalar(@ARGV) != 2)) {
  print("Bad number of argument (".scalar(@ARGV).")\n");
  &usage;
  exit 1;
}

my $h_error_file = $ARGV[0];
my $second_package = 0;
my $only_header = 0;
my $c_error_file;
my $perl_error_file;
my $perl_fullerror_file;
my $perl_fullpackage;
if (scalar(@ARGV) == 2) {
  $perl_error_file = $ARGV[1];
  $only_header = 1;
} else {
  $c_error_file = $ARGV[1];
  $perl_error_file = $ARGV[2];
  if (defined $ARGV[3]) {
    $perl_fullerror_file = $ARGV[3];
    # Create the second package name from the perl_fullerror_file
    $perl_fullpackage = $perl_fullerror_file;
    $perl_fullpackage =~ s/.*\///g;
    $perl_fullpackage =~ s/\..*//g;
    # And open the file
    if (!open(PERL_ERROR_MESS, "+>", $perl_fullerror_file)) {
      print ("ERROR: Cannot open file $perl_fullerror_file for writing");
      exit 1;
    }
    print PERL_ERROR_MESS "# DO NOT EDIT\n";
    print PERL_ERROR_MESS "# This file is automatically generated by c-fullerror-2-perl\n\n";
    print PERL_ERROR_MESS "package ".$perl_fullpackage.";\n\n";
    print PERL_ERROR_MESS "use warnings;\n\n";
    $second_package = 1;
  }
  if (!open(C_ERROR,$c_error_file)) {
    print ("ERROR: Cannot open file $c_error_file");
    exit 1;
  }
}

# Create the main package name from the perl_error_file
my $perl_package = $perl_error_file;
$perl_package =~ s/.*\///g;
$perl_package =~ s/\..*//g;

if (!open(H_ERROR,$h_error_file)) {
  print ("ERROR: Cannot open file $h_error_file");
  exit 1;
}

if (!open(PERL_ERROR, "+>", $perl_error_file)) {
  print ("ERROR: Cannot open file $perl_error_file for writing");
  exit 1;
}


#$ENV{TMP}          = "/tmp" if (!defined $ENV{TMP});
#if (!open(PERL_TMP, "+>", $ENV{TMP} . "/exatmp_error_dumper.pm")) {
#  print ("ERROR: Cannot open file " . $ENV{TMP} . "/exatmp_error_dumper.pm for writing");
#  exit 1;
#}

  print PERL_ERROR "# DO NOT EDIT\n";
  print PERL_ERROR "# This file is automatically generated by c-fullerror-2-perl\n\n";
  print PERL_ERROR "package ".$perl_package.";\n\n";
  print PERL_ERROR "use warnings;\n\n";


# We parse an enum and set the enum_counter as the C compiler would do.
my $enum_counter = 0;
my $in_enum = "NO";
my %all_codes;

my $starting_record = 0;
while (<H_ERROR>) {
#  # We ignore evrything before and after these strings:
#  if ( m/enum exa_error_code \{/ ) {
#    $starting_record = 1;
#    next;  # We ignore this line
#  } elsif ( m/^\}\;/ ) {
#    $starting_record = 0;
#    next;  # We ignore this line
#  }
#  next unless ($starting_record);
  my @fields;
  chomp;

  # Extract the comment if any
  my $comment = "";
  if ( $in_enum !~ "NO" && $_ =~ /\//) {
    $comment = $_;
    $comment =~ s/^[^\/]*\///g;

    # Some cleaning of the comment
    $comment =~ s/^[\/\* ]*//;
    $comment =~ s/[\/\* ]*$//;
  }

  # Get the data now splitted
  @fields = split(/[=,\/]/);

  if($in_enum !~ "NO" && /^}/) {
    $in_enum = "NO";
  }

  if($in_enum !~ "NO") {

    $fields[0] =~ s/[ \t]//g;

    if(defined($fields[1])) {
      $fields[1] =~ s/[ \t]//g;
    }

    if(defined($fields[1]) && $fields[1] ne "") {
	$in_enum = eval($fields[1]);
    } else {
      $in_enum++;
    }

    printf(PERL_ERROR "\$%-40s = %3d;", $fields[0], $in_enum);
    $all_codes{$in_enum} = { variable => "$fields[0]", message => "" };
    #push @all_codes, { code => "$in_enum", variable => "$fields[0]", message => "" } ;

    if($comment) {
      printf(PERL_ERROR "   # %s;", $comment);
    }
    print PERL_ERROR "\n";
  }

  if (/^enum exa_error_code.*{/ || /^typedef enum.*{/) {
    $in_enum = -1;
  }
}

$starting_record = 0;
unless ($only_header) {
  while (<C_ERROR>) {
    # We ignore evrything before and after these strings:
    if ( m/exa_error_msg_table\[\]/ ) {
      $starting_record = 1;
      next;  # We ignore this line
    } elsif ( m/^\}\;/ ) {
      $starting_record = 0;
      next;  # We ignore this line
    }
    next unless ($starting_record);

    # Start to work on the strings
    chomp;

    # Extract the comments if any
    if ( $second_package and /\/\//) {
      s/\/\//\#/;
      print PERL_ERROR_MESS $_ . "\n";
      next; 
    } elsif (/\/\// or /!\w+/ or /^$/) {
      next;
    }

    # We replace the first \{, the first comma and last \} to work on the second package
    s/^\s+\{//;
    s/\}.*//;
    s/\,\ +/\,\ /;
    my ($variable,@error_mess_list) = split(/\,/);
    my $error_mess = join (',', @error_mess_list);
    $error_mess =~ s/^\s+//g;
    printf(PERL_ERROR_MESS "\$%-40s = %s;\n", $variable, $error_mess) if ($second_package);
    $error_mess =~ s/\"//g;

    my $found_variable=0;
    foreach my $code_types (keys %all_codes) {
      if ( $all_codes{$code_types}->{variable} eq "$variable" ) {
	$all_codes{$code_types}->{message} = $error_mess if ( $all_codes{$code_types}->{variable} eq "$variable" );
	$found_variable=1;
	last;
      }
    }
    # Check and die if not ok
    die "\n------------------\nERROR: It seems a variable \"$variable\" from $c_error_file does not have its error code in $h_error_file\n------------------\n" unless ($found_variable);
  }

  if ($second_package) {
    print PERL_ERROR_MESS "# Needed to allow module load\n";
    print PERL_ERROR_MESS "1;\n";
    close PERL_ERROR_MESS;
  }
  print PERL_ERROR "\n\n# Dumper of all the key codes\n";
  print PERL_ERROR Data::Dumper->Dump([\%all_codes], ['$HASH_ERROR_CODES']);
  close C_ERROR;

  # Check and die if we have any empty message error
  foreach my $code_types (keys %all_codes) {
    next if ($code_types == 0); # We ignore "EXA_SUCCESS"
    die "\n------------------\nERROR: It seems a variable \"$all_codes{$code_types}->{variable}\" from $h_error_file does not have any error string in $c_error_file\n------------------\n" if ($all_codes{$code_types}->{message} eq '');
  }
}

print PERL_ERROR "# Needed to allow module load\n";
print PERL_ERROR "1;\n";
close H_ERROR;
close PERL_ERROR;

exit 0;
